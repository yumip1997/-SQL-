## 쿼리 금기사항

### Search ARGument 정의

- 정의 :  Predicate에서 검색 대상 및 범위를 제한할 수 있는 식
    - Where / Having 절의 검색 조건 / From 절의 Join 조건

### Non-SARG 비검색인수

- 인덱스를 활용하는 데 적합하지 않은 조건 식
- Non-SARG가 발생하면, 옵티마이저가 인덱스를 효율적으로 활용하지 못하고 테이블 Full-Scan이 일어날 수 있기에 처리 속도가 저하될 수 있다.
- 검색을 제한하지 않는 식 ⇒ 테이블의 모든 열  

### 기본적인 Non-SARG

1. 불필요한 열 참조
    - 불필요한 열에 LOB가 포함되어 있다면 부하를 초래할 수 있음

```sql
SELECT * FROM dbo.Categories
```

2. 불필요한 행 검색
    - 추가 검색 조건이나 적절한 Paging 처리가 필요하다
    - 아래 예시는 검색 결과 50만건이 Select 되는 SQL 문이다. 이러한 대용량의 데이터는 메로리 부족 등의 문제로 Client에서 소비하지 못할 가능성이 높다. 따라서 검색 조건을 추가하거나 적절한 Paging 처리가 필요하다.

```sql
SELECT * FROM 로그 
WHERE 작성일자 BETWEEN '20200101' AND '20200101 23:59:59'
ORDER BY 작성일자 DESC
```

### Index 사용 방해 요소 Non-SARG

1. Index 열에 부정형 사용 주의
    - 조건은 “=”이 가장 빠르고 효율적이다.
    - 범위 조건을 쓰면 상대적으로 Index 효율이 떨어진다.
    - 부정형을 쓰면 옵티마이저가 긍정형으로 변환하는데, 그 결과는 범위 검색이다. 따라서 인덱스 사용 효율이 떨어지기에, 불필요한 부정형은 지향하는 것이 좋다.
        - NOT IN은 최후의 보루! 가능하면 쓰지 않는 것이 좋다.
    
    ```sql
    ID <> 3 => ID > 3 OR ID < 3
    ID !> 10248 => ID <= 10248
    ID NOT IN (1,3,5) => ID <> 1 AND ID <> 3 AND ID <> 5
    ```
    
    <aside>
    💡 가능하면 긍정 조건 &, 가능하면 “=” 조건으로 쿼리를 짜는 것이 좋다.
    
    </aside>
    

2. Index 열 값 변형
    
    1) Index열에 사칙 연상 적용
    
    2) Index 열에 함수 적용
    
    - 함수를 적용하여 Index 열이 가공된다면 Index를 사용하기 어렵다.
    
    ```sql
    SELECT OrderID
    FROM dbo.Orders
    WHERE Convert(varchar, OrderDate, 112) = '19960704'
    ```
    
    3) Index 열에 암시적 데이터 형 변환
    
    - 데이터 형식이 일치해야 인덱스가 효과적으로 작동한다. 데이터 형식이 일치하지 않으면, 옵티마이저가 올바른 인덱스를 선택하는 데 어려움을 겪게 되기 때문이다. 따라서 인덱스 컬럼이 형변환된 경우, 인덱스 대신 테이블 FULL SCAN이 실행될 가능성이 높다.
    - 서로 다른 데이터 형식을 사용하게 되면 암시적 데이터 형 변환이 일어난다. 인덱스 열에 형 변환이 일어나면 Index를 사용할 수 없다.
    
3. Index에 불필요한 또는 Non-SARG 유형

```sql
SELECT OrderID
FROM dbo.Orders
WHERE CustomerID LIKE 'CE' 
```